import { Vector2 } from "../Math/Vector2";
import { Vector3 } from "../Math/Vector3";
import { Vector4 } from "../Math/Vector4";

//------------------------------------------------------------------------------
// OBJParser
//------------------------------------------------------------------------------

// OBJDoc object
// Constructor
export class OBJDoc {

    public fileName: string;
    public filePath: string;

    public mtls: Array<MTLDoc>;
    public objects: Array<OBJObject>;
    public vertices: Array<Vector3>;
    public uvs: Array<Vector2>;
    public normals: Array<Vector3>;

    public constructor(fileName: string) {
        this.fileName = fileName;
        this.filePath = fileName.slice(0, fileName.lastIndexOf('/') + 1);

        this.mtls = new Array<MTLDoc>();      // Initialize the property for MTL
        this.objects = new Array<OBJObject>();   // Initialize the property for Object
        this.vertices = new Array<Vector3>();  // Initialize the property for Vertex
        this.normals = new Array<Vector3>();   // Initialize the property for Normal
        this.uvs = new Array<Vector2>();
    }

    public async parse(fileString, scale, reverse): Promise<boolean> {
        var lines = fileString.split('\n');  // Break up into lines and store them as array
        lines.push(null); // Append null
        var index = 0;    // Initialize index of line

        var currentObject: OBJObject = new OBJObject(this.fileName);
        this.objects.push(currentObject);

        // Parse line by line
        var line;         // A string in the line to be parsed
        var sp = new StringParser();  // Create StringParser

        while ((line = lines[index++]) != null) {
            sp.init(line);                  // init StringParser
            var command = sp.getWord();     // Get command
            if (command == null) continue;  // check null command

            switch (command) {
                case '#':
                    continue;  // Skip comments
                case 'mtllib':     // Read Material chunk
                    await this.loadMTLFile(this.filePath, sp.getWord());
                    continue; // Go to the next line
                case 'o':
                case 'g':   // Read Object name
                    var object = this.parseObjectName(sp);
                    this.objects.push(object);
                    currentObject = object;
                    continue; // Go to the next line
                case 'v':   // Read vertex
                    var vertex = this.parseVertex(sp, scale);
                    this.vertices.push(vertex);
                    continue; // Go to the next line
                case 'vt':
                    var uv = this.parseUV(sp);
                    this.uvs.push(uv);
                    continue;
                case 'vn':   // Read normal
                    var normal = this.parseNormal(sp);
                    this.normals.push(normal);
                    continue; // Go to the next line
                case 'usemtl': // Read Material name
                    var materialName = this.parseUsemtl(sp);
                    currentObject.material = this.findMaterial(materialName);
                    continue; // Go to the next line
                case 's':
                    continue;
                case 'f': // Read face
                    var face = this.parseFace(sp, this.vertices, reverse);
                    currentObject.addFace(face);
                    continue; // Go to the next line
            }
        }

        return true;
    }

    private loadMTLFile(path: string, fileName: string): Promise<void> {
        return new Promise<void>((resolve) => {

            var mtl = new MTLDoc();
            this.mtls.push(mtl);
            var request = new XMLHttpRequest();

            request.onreadystatechange = function () {
                if (request.readyState == 4) {
                    if (request.status != 404) {
                        onReadMTLFile(request.responseText, mtl, path);
                    }
                    resolve();
                }
            }

            request.open('GET', path + fileName, false);
            request.send();
        });
    }

    private findMaterial(materialName: string): Material | null {
        for (var i = 0; i < this.mtls.length; ++i) {
            var m = this.mtls[i].getMaterial(materialName);
            if (m != null) {
                return m;
            }
        }
        return null;
    }

    private parseObjectName(sp) {
        var name = sp.getWord();
        return (new OBJObject(name));
    }

    private parseVertex(sp, scale) {
        var x = sp.getFloat() * scale;
        var y = sp.getFloat() * scale;
        var z = sp.getFloat() * scale;
        return (new Vector3(x, y, z));
    }

    private parseUV(sp): Vector2 {
        var x = sp.getFloat();
        var y = sp.getFloat();
        return new Vector2(x, y);
    }

    private parseNormal(sp) {
        var x = sp.getFloat();
        var y = sp.getFloat();
        var z = sp.getFloat();
        return (new Vector3(x, y, z));
    }

    private parseUsemtl(sp) {
        return sp.getWord();
    }

    private parseFace(sp, vertices, reverse) {
        var face = new Face();
        // get indices
        for (; ;) {
            var word = sp.getWord();
            if (word == null) break;
            var subWords = word.split('/');
            if (subWords.length >= 1) {
                var vi = parseInt(subWords[0]) - 1;
                face.vIndices.push(vi);
            }

            if (subWords.length >= 2) {
                var ui = parseInt(subWords[1]) - 1;
                face.uIndices.push(ui);
            } else {
                face.uIndices.push(-1);
            }

            if (subWords.length >= 3) {
                var ni = parseInt(subWords[2]) - 1;
                face.nIndices.push(ni);
            } else {
                face.nIndices.push(-1);
            }
        }

        // calc normal
        var v0 = [
            vertices[face.vIndices[0]].x,
            vertices[face.vIndices[0]].y,
            vertices[face.vIndices[0]].z];
        var v1 = [
            vertices[face.vIndices[1]].x,
            vertices[face.vIndices[1]].y,
            vertices[face.vIndices[1]].z];
        var v2 = [
            vertices[face.vIndices[2]].x,
            vertices[face.vIndices[2]].y,
            vertices[face.vIndices[2]].z];

        // 面の法線を計算してnormalに設定
        var normal = calcNormal(v0, v1, v2);
        // 法線が正しく求められたか調べる
        if (normal == null) {
            if (face.vIndices.length >= 4) { // 面が四角形なら別の3点の組み合わせで法線計算
                var v3 = [
                    vertices[face.vIndices[3]].x,
                    vertices[face.vIndices[3]].y,
                    vertices[face.vIndices[3]].z];
                normal = calcNormal(v1, v2, v3);
            }
            if (normal == null) {         // 法線が求められなかったのでY軸方向の法線とする
                normal = new Vector3(0.0, 1.0, 0.0);
            }
        }
        if (reverse) {
            normal[0] = -normal[0];
            normal[1] = -normal[1];
            normal[2] = -normal[2];
        }
        face.normal = new Vector3(normal[0], normal[1], normal[2]);

        // Devide to triangles if face contains over 3 points.
        if (face.vIndices.length > 3) {
            var n = face.vIndices.length - 2;
            var newVIndices = new Array(n * 3);
            var newNIndices = new Array(n * 3);
            for (var i = 0; i < n; i++) {
                newVIndices[i * 3 + 0] = face.vIndices[0];
                newVIndices[i * 3 + 1] = face.vIndices[i + 1];
                newVIndices[i * 3 + 2] = face.vIndices[i + 2];
                newNIndices[i * 3 + 0] = face.nIndices[0];
                newNIndices[i * 3 + 1] = face.nIndices[i + 1];
                newNIndices[i * 3 + 2] = face.nIndices[i + 2];
            }
            face.vIndices = newVIndices;
            face.nIndices = newNIndices;
        }
        face.numIndices = face.vIndices.length;

        return face;
    }

    // Find color by material name
    private findColor(name) {
        for (var i = 0; i < this.mtls.length; i++) {
            for (var j = 0; j < this.mtls[i].materials.length; j++) {
                if (this.mtls[i].materials[j].name == name) {
                    return (this.mtls[i].materials[j].color)
                }
            }
        }
        return (new Vector4(0.8, 0.8, 0.8, 1));
    }

    public getObjs(scale: number, reverse: boolean): Array<OBJObject> {

        var objs = new Array<OBJObject>();

        for (var i = 0; i < this.objects.length; ++i) {

            var object = this.objects[i];
            if (object.faces.length <= 0) {
                continue;
            }

            var numVertices = object.numIndices;
            var vertices = new Float32Array(numVertices * 3);
            var normals = new Float32Array(numVertices * 3);
            var uvs = new Float32Array(numVertices * 2);
            var indices = new Uint16Array(numVertices);

            var index_indices = 0;

            for (var j = 0; j < object.faces.length; j++) {
                var face = object.faces[j];
                var faceNormal = face.normal;

                for (var k = 0; k < face.vIndices.length; k++) {
                    // Set index
                    indices[index_indices] = index_indices;

                    // Copy vertex
                    var vIdx = face.vIndices[k];
                    var vertex = this.vertices[vIdx];
                    vertices[index_indices * 3 + 0] = vertex.x * scale;
                    vertices[index_indices * 3 + 1] = vertex.y * scale;
                    vertices[index_indices * 3 + 2] = vertex.z * scale;

                    // copy uv
                    var uIdx = face.uIndices[k];
                    if (uIdx >= 0 && uIdx < this.uvs.length) {
                        uvs[index_indices * 2 + 0] = this.uvs[uIdx].x;
                        uvs[index_indices * 2 + 1] = this.uvs[uIdx].y;
                    } else {
                        uvs[index_indices * 2 + 0] = 0;
                        uvs[index_indices * 2 + 1] = 0;
                    }

                    // Copy normal
                    var nIdx = face.nIndices[k];
                    if (nIdx >= 0) {
                        var normal = this.normals[nIdx];
                        normals[index_indices * 3 + 0] = normal.x;
                        normals[index_indices * 3 + 1] = normal.y;
                        normals[index_indices * 3 + 2] = normal.z;
                    } else {
                        normals[index_indices * 3 + 0] = faceNormal.x;
                        normals[index_indices * 3 + 1] = faceNormal.y;
                        normals[index_indices * 3 + 2] = faceNormal.z;
                    }

                    if (reverse) {
                        normals[index_indices * 3 + 0] *= -1;
                        normals[index_indices * 3 + 1] *= -1;
                        normals[index_indices * 3 + 2] *= -1;
                    }

                    index_indices++;
                }
            }

            object.vertices = vertices;
            object.uvs = uvs;
            object.normals = normals;
            object.indices = indices;

            objs.push(object);
        }

        return objs;
    }

    //------------------------------------------------------------------------------
    // Retrieve the information for drawing 3D model
    public getDrawingInfo() {
        // Create an arrays for vertex coordinates, normals, colors, and indices
        var numIndices = 0;
        for (var i = 0; i < this.objects.length; i++) {
            numIndices += this.objects[i].numIndices;
        }
        var numVertices = numIndices;
        var vertices = new Float32Array(numVertices * 3);
        var normals = new Float32Array(numVertices * 3);
        var uvs = new Float32Array(numVertices * 2);
        var indices = new Uint16Array(numIndices);

        // Set vertex, normal and color
        var index_indices = 0;
        for (var i = 0; i < this.objects.length; i++) {
            var object = this.objects[i];
            for (var j = 0; j < object.faces.length; j++) {
                var face = object.faces[j];
                var faceNormal = face.normal;
                for (var k = 0; k < face.vIndices.length; k++) {
                    // Set index
                    indices[index_indices] = index_indices;
                    // Copy vertex
                    var vIdx = face.vIndices[k];
                    var vertex = this.vertices[vIdx];
                    vertices[index_indices * 3 + 0] = vertex.x;
                    vertices[index_indices * 3 + 1] = vertex.y;
                    vertices[index_indices * 3 + 2] = vertex.z;
                    // copy uv
                    var uIdx = face.uIndices[k];
                    if (uIdx >= 0) {
                        uvs[index_indices * 2 + 0] = this.uvs[uIdx].x;
                        uvs[index_indices * 2 + 1] = this.uvs[uIdx].y;
                    } else {
                        uvs[index_indices * 2 + 0] = 0;
                        uvs[index_indices * 2 + 1] = 0;
                    }
                    // Copy normal
                    var nIdx = face.nIndices[k];
                    if (nIdx >= 0) {
                        var normal = this.normals[nIdx];
                        normals[index_indices * 3 + 0] = normal.x;
                        normals[index_indices * 3 + 1] = normal.y;
                        normals[index_indices * 3 + 2] = normal.z;
                    } else {
                        normals[index_indices * 3 + 0] = faceNormal.x;
                        normals[index_indices * 3 + 1] = faceNormal.y;
                        normals[index_indices * 3 + 2] = faceNormal.z;
                    }
                    index_indices++;
                }
            }
        }

        return new DrawingInfo(vertices, normals, uvs, indices);
    }
}




// Analyze the material file
function onReadMTLFile(fileString: string, mtlDoc: MTLDoc, path: string) {
    var lines = fileString.split('\n');  // Break up into lines and store them as array
    lines.push('');           // 添加空字符串作为结束标记
    var index = 0;              // Initialize index of line

    // Parse line by line
    var line;      // A string in the line to be parsed
    var sp = new StringParser();  // Create StringParser

    var curMtl: Material | null = null;

    while ((line = lines[index++]) != null) {
        sp.init(line);                  // init StringParser
        var command = sp.getWord();     // Get command
        if (command == null) continue;  // check null command

        switch (command) {
            case '#':
                continue;
            case 'newmtl':
                var name = mtlDoc.parseNewmtl(sp);
                curMtl = new Material(name);
                mtlDoc.materials.push(curMtl);
                continue;
            case 'Kd':
                if (curMtl != null)
                    curMtl.Kd = mtlDoc.parseRGB(sp);
                continue;
            case 'map_Kd':
                if (curMtl != null)
                    curMtl.map_Kd = path + mtlDoc.parseMapPath(sp);
                continue;
        }
    }
}



//------------------------------------------------------------------------------
// MTLDoc Object
//------------------------------------------------------------------------------
export class MTLDoc {
    public materials: Array<Material>;

    constructor() {
        this.materials = new Array<Material>();
    }

    public getMaterial(name: string): Material | null {
        for (var i = 0; i < this.materials.length; ++i) {
            if (this.materials[i].name == name)
                return this.materials[i];
        }
        return null;
    }

    public parseNewmtl(sp) {
        return sp.getWord();
    }

    public parseMapPath(sp) {
        return sp.getWord();
    }

    public parseRGB(sp) {
        var r = sp.getFloat();
        var g = sp.getFloat();
        var b = sp.getFloat();
        return new Vector3(r, g, b);
    }
}



//------------------------------------------------------------------------------
// Material Object
//------------------------------------------------------------------------------

export class Material {
    public name: string;
    public color: Vector4;

    public Ns: number;
    public Ni: number;
    public d: number;
    public illum: number;

    public Ka: Vector3;
    public Kd: Vector3;
    public Ks: Vector3;

    public map_Kd: string;

    public constructor(name) {
        this.name = name;
    }
}


//------------------------------------------------------------------------------
// OBJObject Object
//------------------------------------------------------------------------------
export class OBJObject {
    public name: string;
    public faces: Array<Face>;
    public numIndices: number;
    public material: Material | null;

    public vertices: Float32Array;
    public normals: Float32Array;
    public uvs: Float32Array;
    public indices: Uint16Array;

    public constructor(name) {
        this.name = name;
        this.faces = new Array<Face>();
        this.numIndices = 0;
    }

    public addFace = function (face) {
        this.faces.push(face);
        this.numIndices += face.numIndices;
    }
}




//------------------------------------------------------------------------------
// Face Object
//------------------------------------------------------------------------------
export class Face {
    public vIndices: Array<number>;
    public nIndices: Array<number>;
    public uIndices: Array<number>;
    public normal: Vector3;
    public numIndices: number;

    public constructor() {
        this.vIndices = new Array<number>();
        this.nIndices = new Array<number>();
        this.uIndices = new Array<number>();
    }
}


//------------------------------------------------------------------------------
// DrawInfo Object
//------------------------------------------------------------------------------
export class DrawingInfo {
    public vertices: Float32Array;
    public normals: Float32Array;
    public uvs: Float32Array;
    public indices: Uint16Array;

    public constructor(vertices, normals, uvs, indices) {
        this.vertices = vertices;
        this.normals = normals;
        this.indices = indices;
        this.uvs = uvs;
    }
}


//------------------------------------------------------------------------------
// Constructor
export class StringParser {
    public str: string;
    public index: number;

    public constructor() {

    }

    // Initialize StringParser object
    public init(str) {
        this.str = str;
        this.index = 0;
    }

    // Skip delimiters
    public skipDelimiters() {
        for (var i = this.index, len = this.str.length; i < len; i++) {
            var c = this.str.charAt(i);
            // Skip TAB, Space, '(', ')
            if (c == '\t' || c == ' ' || c == '(' || c == ')' || c == '"') continue;
            break;
        }
        this.index = i;
    }

    // Skip to the next word
    public skipToNextWord() {
        this.skipDelimiters();
        var n = getWordLength(this.str, this.index);
        this.index += (n + 1);
    }

    // Get word
    public getWord(): string {
        this.skipDelimiters();
        var n = getWordLength(this.str, this.index);
        if (n == 0) return "";
        var word = this.str.substr(this.index, n);
        this.index += (n + 1);

        return word;
    }

    // Get integer
    public getInt() {
        return parseInt(this.getWord());
    }

    // Get floating number
    public getFloat() {
        return parseFloat(this.getWord());
    }
}


// Get the length of word
function getWordLength(str, start) {
    var n = 0;
    for (var i = start, len = str.length; i < len; i++) {
        var c = str.charAt(i);
        if (c == '\t' || c == ' ' || c == '(' || c == ')' || c == '"')
            break;
    }
    return i - start;
}

//------------------------------------------------------------------------------
// Common function
//------------------------------------------------------------------------------
function calcNormal(p0, p1, p2): Vector3 {
    // v0: a vector from p1 to p0, v1; a vector from p1 to p2
    var v0 = new Float32Array(3);
    var v1 = new Float32Array(3);
    for (var i = 0; i < 3; i++) {
        v0[i] = p0[i] - p1[i];
        v1[i] = p2[i] - p1[i];
    }

    // The cross product of v0 and v1
    var c = new Float32Array(3);
    c[0] = v0[1] * v1[2] - v0[2] * v1[1];
    c[1] = v0[2] * v1[0] - v0[0] * v1[2];
    c[2] = v0[0] * v1[1] - v0[1] * v1[0];

    // Normalize the result
    var v = new Vector3(c[0], c[1], c[2]);
    v.normalize();
    return v;
}