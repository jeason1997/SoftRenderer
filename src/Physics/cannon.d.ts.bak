/**
 * TypeScript declarations for Cannon.js 0.6.2
 * Lightweight 3D physics engine
 */

declare namespace CANNON  {
  // 数学类
  export class Vec3 {
    constructor(x?: number, y?: number, z?: number);
    x: number;
    y: number;
    z: number;
    
    static ZERO: Vec3;
    static UNIT_X: Vec3;
    static UNIT_Y: Vec3;
    static UNIT_Z: Vec3;
    
    cross(v: Vec3, target?: Vec3): Vec3;
    set(x: number, y: number, z: number): Vec3;
    setZero(): void;
    vadd(v: Vec3, target?: Vec3): Vec3;
    vsub(v: Vec3, target?: Vec3): Vec3;
    crossmat(): Mat3;
    normalize(): number;
    unit(target?: Vec3): Vec3;
    norm(): number;
    length(): number;
    norm2(): number;
    lengthSquared(): number;
    distanceTo(p: Vec3): number;
    distanceSquared(p: Vec3): number;
    mult(scalar: number, target?: Vec3): Vec3;
    scale(scalar: number, target?: Vec3): Vec3;
    dot(v: Vec3): number;
    isZero(): boolean;
    negate(target?: Vec3): Vec3;
    tangents(t1: Vec3, t2: Vec3): void;
    toString(): string;
    toArray(): number[];
    copy(source: Vec3): Vec3;
    lerp(v: Vec3, t: number, target: Vec3): void;
    almostEquals(v: Vec3, precision?: number): boolean;
    almostZero(precision?: number): boolean;
    isAntiparallelTo(v: Vec3, precision?: number): boolean;
    clone(): Vec3;
  }
  
  export class Mat3 {
    constructor(data?: number[]);
    elements: number[];
    
    identity(): void;
    setZero(): void;
    setTrace(vec3: Vec3): void;
    getTrace(target?: Vec3): Vec3;
    vmult(v: Vec3, target?: Vec3): Vec3;
    smult(s: number): void;
    mmult(m: Mat3, target?: Mat3): Mat3;
    scale(v: Vec3, target?: Mat3): Mat3;
    solve(b: Vec3, target?: Vec3): Vec3;
    e(row: number, column: number, value?: number): number;
    copy(source: Mat3): Mat3;
    toString(): string;
    reverse(target?: Mat3): Mat3;
    setRotationFromQuaternion(q: Quaternion): Mat3;
    transpose(target?: Mat3): Mat3;
  }
  
  export class Quaternion {
    constructor(x?: number, y?: number, z?: number, w?: number);
    x: number;
    y: number;
    z: number;
    w: number;
    
    set(x: number, y: number, z: number, w: number): void;
    toString(): string;
    toArray(): number[];
    setFromAxisAngle(axis: Vec3, angle: number): void;
    toAxisAngle(targetAxis?: Vec3): [Vec3, number];
    setFromVectors(u: Vec3, v: Vec3): void;
    mult(q: Quaternion, target?: Quaternion): Quaternion;
    inverse(target?: Quaternion): Quaternion;
    conjugate(target?: Quaternion): Quaternion;
    normalize(): void;
    normalizeFast(): void;
    vmult(v: Vec3, target?: Vec3): Vec3;
    copy(source: Quaternion): Quaternion;
    toEuler(target: Vec3, order?: string): void;
    setFromEuler(x: number, y: number, z: number, order?: string): Quaternion;
    clone(): Quaternion;
  }
  
  // 碰撞检测相关
  export class AABB {
    constructor(options?: { lowerBound?: Vec3; upperBound?: Vec3 });
    
    lowerBound: Vec3;
    upperBound: Vec3;
    
    setFromPoints(points: Vec3[], position?: Vec3, quaternion?: Quaternion, skinSize?: number): AABB;
    copy(aabb: AABB): AABB;
    clone(): AABB;
    extend(aabb: AABB): void;
    overlaps(aabb: AABB): boolean;
    contains(aabb: AABB): boolean;
    getCorners(a: Vec3, b: Vec3, c: Vec3, d: Vec3, e: Vec3, f: Vec3, g: Vec3, h: Vec3): void;
    toLocalFrame(frame: Transform, target: AABB): AABB;
    toWorldFrame(frame: Transform, target: AABB): AABB;
  }
  
  export class ArrayCollisionMatrix {
    constructor();
    
    matrix: number[];
    
    get(i: { index: number }, j: { index: number }): number;
    set(i: { index: number }, j: { index: number }, value: number): void;
    reset(): void;
    setNumObjects(n: number): void;
  }
  
  export class Ray {
    constructor(from?: Vec3, to?: Vec3);
    
    from: Vec3;
    to: Vec3;
    _direction: Vec3;
    precision: number;
    checkCollisionResponse: boolean;
    skipBackfaces: boolean;
    collisionFilterMask: number;
    collisionFilterGroup: number;
    mode: number;
    result: RaycastResult;
    hasHit: boolean;
    callback: (result: RaycastResult) => void;
    
    static CLOSEST: number;
    static ANY: number;
    static ALL: number;
    
    intersectWorld(world: World, options: any): boolean;
    intersectBody(body: Body, result?: RaycastResult): void;
    intersectBodies(bodies: Body[], result?: RaycastResult): void;
    _updateDirection(): void;
    intersectShape(shape: Shape, quat: Quaternion, position: Vec3, body: Body): void;
    intersectBox(shape: Box, quat: Quaternion, position: Vec3, body: Body): void;
    intersectPlane(shape: any, quat: Quaternion, position: Vec3, body: Body): void;
  }
  
  export class RaycastResult {
    constructor();
    
    rayFromWorld: Vec3;
    rayToWorld: Vec3;
    hitNormalWorld: Vec3;
    hitPointWorld: Vec3;
    hasHit: boolean;
    shape: Shape | null;
    body: Body | null;
    hitFaceIndex: number;
    distance: number;
    
    reset(): void;
    abort(): void;
    set(rayFromWorld: Vec3, rayToWorld: Vec3, hitNormalWorld: Vec3, hitPointWorld: Vec3, shape: Shape, body: Body, distance: number): void;
  }
  
  // 材质
  export class Material {
    constructor(options?: string | { friction?: number; restitution?: number });
    id: number;
    name: string;
    friction: number;
    restitution: number;
    
    static idCounter: number;
  }
  
  export class ContactMaterial {
    constructor(materialA: Material, materialB: Material, options?: {
      friction?: number;
      restitution?: number;
      contactEquationStiffness?: number;
      contactEquationRelaxation?: number;
      frictionEquationStiffness?: number;
      frictionEquationRelaxation?: number;
    });
    
    id: number;
    materials: Material[];
    friction: number;
    restitution: number;
    contactEquationStiffness: number;
    contactEquationRelaxation: number;
    frictionEquationStiffness: number;
    frictionEquationRelaxation: number;
    
    static idCounter: number;
  }
  
  // 形状
  export class Shape {
    constructor();
    id: number;
    type: number;
    boundingSphereRadius: number;
    collisionResponse: boolean;
    material: Material | null;
    
    updateBoundingSphereRadius(): number;
    volume(): number;
    calculateLocalInertia(mass: number, target?: Vec3): Vec3;
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void;
    
    static idCounter: number;
    static types: {
      SPHERE: number;
      PLANE: number;
      BOX: number;
      COMPOUND: number;
      CONVEXPOLYHEDRON: number;
      HEIGHTFIELD: number;
      PARTICLE: number;
      CYLINDER: number;
      TRIMESH: number;
    };
  }
  
  export class Box extends Shape {
    constructor(halfExtents: Vec3);
    halfExtents: Vec3;
    convexPolyhedronRepresentation: any;
    
    updateConvexPolyhedronRepresentation(): void;
    calculateLocalInertia(mass: number, target?: Vec3): Vec3;
    volume(): number;
    updateBoundingSphereRadius(): number;
    getSideNormals(sixTargetVectors: Vec3[], quat?: Quaternion): Vec3[];
    forEachWorldCorner(pos: Vec3, quat: Quaternion, callback: (x: number, y: number, z: number) => void): void;
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void;
    
    static calculateInertia(halfExtents: Vec3, mass: number, target: Vec3): void;
  }
  
  export class Sphere extends Shape {
    constructor(radius: number);
    radius: number;
    
    calculateLocalInertia(mass: number, target?: Vec3): Vec3;
    volume(): number;
    updateBoundingSphereRadius(): number;
    calculateWorldAABB(pos: Vec3, quat: Quaternion, min: Vec3, max: Vec3): void;
  }
  
  export class Cylinder extends Shape {
    constructor(radiusTop: number, radiusBottom: number, height: number, numSegments: number);
    radiusTop: number;
    radiusBottom: number;
    height: number;
    numSegments: number;
  }
  
  // 物体
  export class Body extends EventTarget {
    constructor(options?: {
      position?: Vec3;
      velocity?: Vec3;
      angularVelocity?: Vec3;
      quaternion?: Quaternion;
      mass?: number;
      material?: Material;
      type?: number;
      linearDamping?: number;
      angularDamping?: number;
      allowSleep?: boolean;
      sleepSpeedLimit?: number;
      sleepTimeLimit?: number;
      collisionFilterGroup?: number;
      collisionFilterMask?: number;
      fixedRotation?: boolean;
    });
    
    id: number;
    world: World | null;
    collisionFilterGroup: number;
    collisionFilterMask: number;
    collisionResponse: boolean;
    position: Vec3;
    previousPosition: Vec3;
    initPosition: Vec3;
    velocity: Vec3;
    initVelocity: Vec3;
    force: Vec3;
    mass: number;
    invMass: number;
    material: Material | null;
    linearDamping: number;
    type: number;
    allowSleep: boolean;
    sleepState: number;
    sleepSpeedLimit: number;
    sleepTimeLimit: number;
    torque: Vec3;
    quaternion: Quaternion;
    initQuaternion: Quaternion;
    angularVelocity: Vec3;
    initAngularVelocity: Vec3;
    interpolatedPosition: Vec3;
    interpolatedQuaternion: Quaternion;
    shapes: Shape[];
    shapeOffsets: Vec3[];
    shapeOrientations: Quaternion[];
    inertia: Vec3;
    invInertia: Vec3;
    invInertiaWorld: Mat3;
    invMassSolve: number;
    invInertiaSolve: Vec3;
    invInertiaWorldSolve: Mat3;
    fixedRotation: boolean;
    angularDamping: number;
    aabb: AABB;
    aabbNeedsUpdate: boolean;
    boundingRadius: number;
    
    // 方法
    addShape(shape: Shape, offset?: Vec3, orientation?: Quaternion): Body;
    applyForce(force: Vec3, worldPoint: Vec3): void;
    applyLocalForce(localForce: Vec3, localPoint: Vec3): void;
    applyImpulse(impulse: Vec3, worldPoint: Vec3): void;
    applyLocalImpulse(localImpulse: Vec3, localPoint: Vec3): void;
    wakeUp(): void;
    sleep(): void;
    sleepTick(time: number): void;
    pointToLocalFrame(worldPoint: Vec3, result?: Vec3): Vec3;
    vectorToLocalFrame(worldVector: Vec3, result?: Vec3): Vec3;
    pointToWorldFrame(localPoint: Vec3, result?: Vec3): Vec3;
    vectorToWorldFrame(localVector: Vec3, result?: Vec3): Vec3;
    computeAABB(): void;
    updateMassProperties(): void;
    updateInertiaWorld(force: boolean): void;
    updateBoundingRadius(): void;
    updateSolveMassProperties(): void;
    getVelocityAtWorldPoint(worldPoint: Vec3, result: Vec3): Vec3;
    
    // 静态常量
    static DYNAMIC: number;
    static STATIC: number;
    static KINEMATIC: number;
    static AWAKE: number;
    static SLEEPY: number;
    static SLEEPING: number;
    static idCounter: number;
  }
  
  // 约束
  export class Constraint {
    constructor(bodyA: Body, bodyB: Body, options?: {
      collideConnected?: boolean;
      wakeUpBodies?: boolean;
    });
    
    equations: Equation[];
    bodyA: Body;
    bodyB: Body;
    id: number;
    collideConnected: boolean;
    
    update(): void;
    enable(): void;
    disable(): void;
    
    static idCounter: number;
  }
  
  export class DistanceConstraint extends Constraint {
    constructor(bodyA: Body, bodyB: Body, distance: number, maxForce?: number);
    
    distance: number;
    maxForce: number;
    equation: Equation;
  }
  
  export class PointToPointConstraint extends Constraint {
    constructor(bodyA: Body, pivotA: Vec3, bodyB?: Body, pivotB?: Vec3, maxForce?: number);
    
    pivotA: Vec3;
    pivotB: Vec3;
    equationX: ContactEquation;
    equationY: ContactEquation;
    equationZ: ContactEquation;
    
    update(): void;
  }
  
  // 方程
  export class JacobianElement {
    spatial: Vec3;
    rotational: Vec3;
    
    multiplyElement(element: JacobianElement): number;
    multiplyVectors(spatial: Vec3, rotational: Vec3): number;
  }
  
  export class Equation {
    constructor(bi: Body, bj: Body, minForce?: number, maxForce?: number);
    
    id: number;
    minForce: number;
    maxForce: number;
    bi: Body;
    bj: Body;
    a: number;
    b: number;
    eps: number;
    jacobianElementA: JacobianElement;
    jacobianElementB: JacobianElement;
    enabled: boolean;
    
    setSpookParams(stiffness: number, relaxation: number, timeStep: number): void;
    computeB(a: number, b: number, h: number): number;
    computeGq(): number;
    computeGW(): number;
    computeGWlambda(): number;
    computeGiMf(): number;
    computeGiMGt(): number;
    addToWlambda(deltalambda: number): void;
    computeC(): number;
    
    static id: number;
  }
  
  export class ContactEquation extends Equation {
    constructor(bodyA: Body, bodyB: Body, maxForce?: number);
    
    restitution: number;
    ri: Vec3;
    rj: Vec3;
    ni: Vec3;
    
    computeB(h: number): number;
    getImpactVelocityAlongNormal(): number;
  }
  
  export class FrictionEquation extends Equation {
    constructor(bodyA: Body, bodyB: Body, slipForce: number);
    
    t: Vec3;
    ni: Vec3;
    ri: Vec3;
    rj: Vec3;
  }
  
  // 求解器
  export class Solver {
    constructor();
    
    equations: Equation[];
    
    solve(dt: number, world: World): number;
    addEquation(eq: Equation): void;
    removeEquation(eq: Equation): void;
    removeAllEquations(): void;
  }
  
  export class GSSolver extends Solver {
    constructor();
    
    iterations: number;
    tolerance: number;
    
    solve(dt: number, world: World): number;
  }
  
  // 事件目标类
  export class EventTarget {
    addEventListener(type: string, listener: Function): void;
    removeEventListener(type: string, listener: Function): void;
    dispatchEvent(event: { type: string; target: any }): void;
  }

  export class Transform {
    constructor(options?: { position?: Vec3; quaternion?: Quaternion });
    
    position: Vec3;
    quaternion: Quaternion;
    
    static pointToLocalFrame(position: Vec3, quaternion: Quaternion, worldPoint: Vec3, result: Vec3): Vec3;
    static pointToWorldFrame(position: Vec3, quaternion: Quaternion, localPoint: Vec3, result: Vec3): Vec3;
    static vectorToWorldFrame(quaternion: Quaternion, localVector: Vec3, result: Vec3): Vec3;
    static vectorToLocalFrame(position: Vec3, quaternion: Quaternion, worldVector: Vec3, result: Vec3): Vec3;
    
    pointToLocal(worldPoint: Vec3, result: Vec3): Vec3;
    pointToWorld(localPoint: Vec3, result: Vec3): Vec3;
    vectorToWorldFrame(localVector: Vec3, result: Vec3): Vec3;
  }
  
  // 世界
  export class World extends EventTarget {
    constructor();
    
    dt: number;
    allowSleep: boolean;
    contacts: ContactEquation[];
    frictionEquations: FrictionEquation[];
    quatNormalizeSkip: number;
    quatNormalizeFast: boolean;
    time: number;
    stepnumber: number;
    default_dt: number;
    nextId: number;
    gravity: Vec3;
    broadphase: any;
    bodies: Body[];
    solver: Solver;
    constraints: Constraint[];
    narrowphase: any;
    collisionMatrix: any;
    collisionMatrixPrevious: any;
    materials: Material[];
    contactmaterials: ContactMaterial[];
    contactMaterialTable: any;
    defaultMaterial: Material;
    defaultContactMaterial: ContactMaterial;
    doProfiling: boolean;
    profile: {
      solve: number;
      makeContactConstraints: number;
      broadphase: number;
      integrate: number;
      narrowphase: number;
    };
    subsystems: any[];
    
    // 方法
    getContactMaterial(m1: Material, m2: Material): ContactMaterial | null;
    numObjects(): number;
    collisionMatrixTick(): void;
    add(body: Body): void;
    addBody(body: Body): void;
    addConstraint(c: Constraint): void;
    removeConstraint(c: Constraint): void;
    rayTest(from: Vec3, to: Vec3, result: Function | RaycastResult): void;
    raycastAll(from: Vec3, to: Vec3, options: {
      collisionFilterMask?: number;
      collisionFilterGroup?: number;
      skipBackfaces?: boolean;
      checkCollisionResponse?: boolean;
    }, callback: Function): boolean;
    raycastAny(from: Vec3, to: Vec3, options: {
      collisionFilterMask?: number;
      collisionFilterGroup?: number;
      skipBackfaces?: boolean;
      checkCollisionResponse?: boolean;
    }, result: RaycastResult): boolean;
    raycastClosest(from: Vec3, to: Vec3, options: {
      collisionFilterMask?: number;
      collisionFilterGroup?: number;
      skipBackfaces?: boolean;
      checkCollisionResponse?: boolean;
    }, result: RaycastResult): boolean;
    remove(body: Body): void;
    removeBody(body: Body): void;
    addMaterial(m: Material): void;
    addContactMaterial(cmat: ContactMaterial): void;
    step(dt: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
    clearForces(): void;
  }
  
  // 常量和枚举
  export const BODY_TYPES: {
    STATIC: number;
    DYNAMIC: number;
    KINEMATIC: number;
  };
  
  export const SHAPE_TYPES: {
    SPHERE: number;
    PLANE: number;
    BOX: number;
    COMPOUND: number;
    CONVEXPOLYHEDRON: number;
    HEIGHTFIELD: number;
    PARTICLE: number;
    CYLINDER: number;
    TRIMESH: number;
  };
}

declare module "cannon" {
    export = CANNON;
}