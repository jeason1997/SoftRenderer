需求：安装nodejs
初始：npm install
启动gulp监控自动编译任务：gulp
启动项目：npx serve
浏览器打开

1.绘制直线
    a.要根据斜率考虑是以x为循环量还是以y为循环量递增画点
    b.我们总是从左往右，或从上往下开始绘制点，所以需要判断两点的关系，如果不满足，交换两点的位置
    c.性能优化，例如在递增x求y时，不必用y=ax+b求y，而是直接通过规律来y_new = y_old+a直接获取
    d.优化，画线前进行边缘检测，确保线的两个端点都在屏幕上，避免绘制超出屏幕的线，造成大量的性能浪费，如果线段超出屏幕，则把超出部分裁剪

2.绘制填充三角形
    a.对三角形的三个点进行y轴排序，使得y1<=y2<=y3，排序完后，可以确定，L13是垂直距离最长的边，L12,L23则是两条短边
    b.分别获取这三条边在y轴上均匀分布时对应的x轴点
    c.将L12跟L23的点合并起来
    d.判断L13和L123哪条长边是左哪条是右，都取数组中间的点，判断谁左谁右即可
    e.从y1开始遍历到y3，每次遍历到一个y值，分别获取L13和L123在这个y值对应的x轴点，将这两个点画为一条横线，即可实现填充三角形

3.绘制顶点色三角形，在上面步骤上修改2步
    b.[同上]，同时获取每条边两个顶点的颜色在这些x轴对应点上的插值颜色
    e.[同上]，同时获取这条横线左右两个点对应的初始颜色，然后插值到这条线上每一个点上

4.透视投影与视口映射
    a.视口就是一个2D的矩形区域，我们的3D场景会被投影到这个矩形区域上，通常我们默认视口的宽为1，则高为1/(canvasWidth/canvasHeight)
    b.视口的大小以及视点（摄像机）到视口的距离，决定了我们观看这个世界的角度，即视野，也称FOV（一般设置为60）
    c.透视投影就是将3D场景里的坐标投影到2D视口平面上，即距离越远的点，在屏幕上的大小越小。
    b.根据相似三角形原理，透视投影的公式就是：x'=(d*x)/z, y'=(d*y)/z，其中d是视点离视口的距离，是由FOV决定的，具体公式是：tan(fov/2) = (0.5 / d)
    c.视口映射，就是将视口上的内容映射到实际屏幕上，比如X坐标：从 [-viewportWidth/2, viewportWidth/2] 映射到 [0, canvasWidth]

5.简单变换
    a.先缩放，再旋转，再平移
    b.缩放就是顶点直接乘缩放比例
    c.旋转就是顶点计算三角函数，根据旋转角度计算出sin值和cos值，然后用三角函数公式计算出旋转后的坐标
    d.平移就是顶点直接加平移向量

6.加载obj模型
    a.解析obj文件，获取顶点，三角形索引，顶点颜色

7.将上面的简单变换跟投影改为MVP矩阵

8.裁剪
    包围盒：
        AABB：
        OBB：
        球体：
    裁剪过程：
        第一步：遍历场景所有实例，判断每个物体是否需要显示
        第二步：判断包围盒，如果包围盒完全在视锥体里，则显示，完全不在则不显示，与视锥体有交集的话，进行下一步（需要判断是否与多个视锥面有相交，有可能出现实例与多个面有相交）
        第三步：遍历该实例的所有三角形，如果三个顶点都在视锥体里，则显示，如果都不在，则不显示，如果部分点在视锥体里，进行下一步（同样需要判断是否与多个面相交）
        第四步：先抛弃该三角形。如果只有一个顶点在视锥体里，并且将该顶点与相交面的另外两个点组成新三角形。如果两个点在视锥体里，则这2个顶点与相交面的另外2个顶点构成2个新三角形。

9.背面裁剪
    a.判断三角形是否是正面，即判断三角形的法线是否指向相机，三角形的法线可通过三角形的顶点构成两个向量，进行叉乘计算，然后再转到相机空间。
    b.判断三角形的法向量跟相机朝向的点积来判断夹角关系，如果法线指向相机，则是正面，否则是反面，反面的三角形不进行渲染。
    c.性能优化，没必要在每个渲染帧都计算三角形的法线，可以在导入模型时预计算好面的法线，然后在裁剪时，直接将这个法线转到相机空间即可。(预计算仅支持静态模型)

10.深度缓冲
    a.深度缓冲区，用于存储每个像素的深度值，深度值越小，越靠近相机
    b.深度测试，在绘制每个像素时，判断该像素的深度值是否小于深度缓冲区中的值，如果是，则绘制该像素，否则不绘制
    c.深度缓冲区的初始化，在绘制前，需要将深度缓冲区清空，即设置所有像素的深度值为最大深度值
    d.深度缓冲区的更新，在绘制每个像素时，需要更新深度缓冲区中的值，即设置该像素的深度值为当前像素的深度值

齐次坐标中的w,w=1时表示点，w=0时表示向量
​点​会​​被平移变换影响
​​方向不会​​被平移变换影响（仅响应旋转和缩放）
即有平移矩阵M，有点(x,y,z,1)和向量(x,y,z,0)，M*点=平移后的点，M*向量=向量




TODO:
1.四元素的欧拉角有BUG，万向锁问题，暂时只能通过Quaternion.angleAxis来设置角度
2.深度缓冲区，模板缓冲区
3.PBR着色
4.后处理
5.Forward+路径，以及尝试延迟渲染
6.阴影
7.环境光遮蔽
8.物理引擎
9.光线追踪渲染器
10.鼠标点击选取场景物体
11.引擎上下文Content，支持多个引擎实例
12.GPU加速，看能不能把顶点或像素计算，通过计算着色器计算后返回结果
13.看能不能搞一个脚本，实现将GLSL代码转为TS