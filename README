需求：安装nodejs
初始：npm install
启动gulp监控自动编译任务：gulp
启动项目：npx serve
浏览器打开

1.绘制直线
    a.要根据斜率考虑是以x为循环量还是以y为循环量递增画点
    b.我们总是从左往右，或从上往下开始绘制点，所以需要判断两点的关系，如果不满足，交换两点的位置
    c.性能优化，例如在递增x求y时，不必用y=ax+b求y，而是直接通过规律来y_new = y_old+a直接获取

2.绘制填充三角形
    a.对三角形的三个点进行y轴排序，使得y1<=y2<=y3，排序完后，可以确定，L13是垂直距离最长的边，L12,L23则是两条短边
    b.分别获取这三条边在y轴上均匀分布时对应的x轴点
    c.将L12跟L23的点合并起来
    d.判断L13和L123哪条长边是左哪条是右，都取数组中间的点，判断谁左谁右即可
    e.从y1开始遍历到y3，每次遍历到一个y值，分别获取L13和L123在这个y值对应的x轴点，将这两个点画为一条横线，即可实现填充三角形

3.绘制顶点色三角形，在上面步骤上修改2步
    b.[同上]，同时获取每条边两个顶点的颜色在这些x轴对应点上的插值颜色
    e.[同上]，同时获取这条横线左右两个点对应的初始颜色，然后插值到这条线上每一个点上

4.透视投影与视口映射
    a.视口就是一个2D的矩形区域，我们的3D场景会被投影到这个矩形区域上，通常我们默认视口的宽为1，则高为1/(canvasWidth/canvasHeight)
    b.视口的大小以及视点（摄像机）到视口的距离，决定了我们观看这个世界的角度，即视野，也称FOV（一般设置为60）
    c.透视投影就是将3D场景里的坐标投影到2D视口平面上，即距离越远的点，在屏幕上的大小越小。
    b.根据相似三角形原理，透视投影的公式就是：x'=(d*x)/z, y'=(d*y)/z，其中d是视点离视口的距离，是由FOV决定的，具体公式是：tan(fov/2) = (0.5 / d)
    c.视口映射，就是将视口上的内容映射到实际屏幕上，比如X坐标：从 [-viewportWidth/2, viewportWidth/2] 映射到 [0, canvasWidth]

5.简单变换
    a.先缩放，再旋转，再平移
    b.缩放就是顶点直接乘缩放比例
    c.旋转就是顶点计算三角函数，根据旋转角度计算出sin值和cos值，然后用三角函数公式计算出旋转后的坐标
    d.平移就是顶点直接加平移向量

6.加载obj模型
    a.解析obj文件，获取顶点，三角形索引，顶点颜色

7.将上面的简单变换跟投影改为MVP矩阵

8.裁剪
    简单包围球，求物体的包围盒算法复杂了点，简单处理就是生成包围盒，遍历所有顶点，算出坐标平均值，得到中心点，半径则是离中心点最远距离点的距离
    a.裁剪就是将三角形中超出视口范围的部分裁剪掉
    b.裁剪的方法就是判断三角形的三个顶点是否在视口范围内，如果不在，就将这个顶点的坐标设置为视口的边界坐标，然后再判断是否在视口范围内，直到在视口范围内为止
    c.如果三角形的三个顶点都在视口范围内，就说明这个三角形是可见的，否则就是不可见的
CPU阶段裁剪：视锥体，游戏物体剔除。遮挡剔除
GPU阶段裁剪：
裁剪过程：
    第一步：遍历场景所有实例，判断每个物体是否需要显示
    第二步：判断包围球，如果包围球完全在视锥体里，则显示，完全不在则不显示，与视锥体有交集的话，进行下一步（需要判断是否与多个视锥面有相交，有可能出现实例与多个面有相交）
    第三步：遍历该实例的所有三角形，如果三个顶点都在视锥体里，则显示，如果都不在，则不显示，如果部分点在视锥体里，进行下一步（同样需要判断是否与多个面相交）
    第四步：先抛弃该三角形。如果只有一个顶点在视锥体里，并且将该顶点与相交面的另外两个点组成新三角形。如果两个点在视锥体里，则这2个顶点与相交面的另外2个顶点构成2个新三角形。


齐次坐标中的w,w=1时表示点，w=0时表示向量
​点​会​​被平移变换影响
​​方向不会​​被平移变换影响（仅响应旋转和缩放）
即有平移矩阵M，有点(x,y,z,1)和向量(x,y,z,0)，M*点=平移后的点，M*向量=向量




TODO:四元素的欧拉角有BUG，万向锁问题，暂时只能通过Quaternion.angleAxis来设置角度